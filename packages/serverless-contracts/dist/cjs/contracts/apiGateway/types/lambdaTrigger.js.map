{"version":3,"file":"lambdaTrigger.js","names":[],"sources":["../../../../../src/contracts/apiGateway/types/lambdaTrigger.ts"],"sourcesContent":["import { AWS } from '@serverless/typescript';\nimport { O } from 'ts-toolbelt';\n\nimport { CleanEmptyObject, Unpacked } from 'types/utilities';\n\nimport { ApiGatewayContract } from '../apiGatewayContract';\nimport {\n  ApiGatewayAuthorizerType,\n  ApiGatewayIntegrationType,\n  ApiGatewayKey,\n} from './constants';\n\n/**\n * map between our integration types (httpApi vs restApi) and\n * serverless's triggers\n */\nexport type ApiGatewayTriggerKey<\n  ApiGatewayIntegration extends ApiGatewayIntegrationType,\n> = ApiGatewayIntegration extends 'httpApi' ? 'httpApi' : 'http';\n\n/**\n * The type of an httpApi lambda trigger\n */\nexport type ApiGatewayLambdaCompleteTriggerType<\n  Key extends ApiGatewayKey,\n  AuthorizerType extends ApiGatewayAuthorizerType,\n> = {\n  [key in Key]: {\n    path: string;\n    method: string;\n  } & ApiGatewayLambdaAdditionalConfigType<Key, AuthorizerType>;\n};\n\n/**\n * From @serverless/typescript, we get the type of a single lambda config\n */\nexport type LambdaFunction = Exclude<AWS['functions'], undefined>[string];\n\n/**\n * Narrowing the type of a lambda config to the type of its events\n */\ntype LambdaEvents = Unpacked<LambdaFunction['events']>;\n\n/**\n * basic additional config a user can define on an ApiGateway trigger.\n *\n * This doesn't include `path` and `method` as they are already defined in the contract itself.\n *\n * Also this does not take into account the authorizerType, do not use directly\n */\ntype ApiGatewayLambdaAdditionalConfigSimpleType<\n  IntegrationType extends ApiGatewayKey,\n> = Omit<\n  Exclude<\n    Extract<LambdaEvents, Record<IntegrationType, unknown>>[IntegrationType],\n    string\n  >,\n  'path' | 'method'\n>;\n\n/**\n * represents additional config a user can define on an ApiGateway trigger.\n *\n * This doesn't include `path` and `method` as they are already defined in the contract itself.\n */\ntype ApiGatewayLambdaAdditionalConfigType<\n  IntegrationType extends ApiGatewayKey,\n  AuthorizerType extends ApiGatewayAuthorizerType,\n> = AuthorizerType extends undefined\n  ? CleanEmptyObject<\n      O.Omit<\n        ApiGatewayLambdaAdditionalConfigSimpleType<IntegrationType>,\n        'authorizer'\n      >\n    >\n  : O.Required<\n      ApiGatewayLambdaAdditionalConfigSimpleType<IntegrationType>,\n      'authorizer'\n    >;\n\n/**\n * the arguments array of the `getTrigger` function`\n *\n * the trick here is that when the contract is authenticated, the additional config\n * is required, whereas otherwise it is optional\n */\nexport type ApiGatewayTriggerArgs<Contract extends ApiGatewayContract> =\n  Contract['authorizerType'] extends undefined\n    ?\n        | [\n            Contract,\n            ApiGatewayLambdaAdditionalConfigType<\n              ApiGatewayTriggerKey<Contract['integrationType']>,\n              Contract['authorizerType']\n            >,\n          ]\n        | [Contract]\n    : [\n        Contract,\n        ApiGatewayLambdaAdditionalConfigType<\n          ApiGatewayTriggerKey<Contract['integrationType']>,\n          Contract['authorizerType']\n        >,\n      ];\n"],"mappings":""}